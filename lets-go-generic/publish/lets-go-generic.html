
<!DOCTYPE html>
<html>
  <head>
    <title>Let&#39;s Go generic</title>
    <meta charset='utf-8'>
    <script src='static/slides.js'></script>
  </head>

  <body style='display: none'>

    <section class='slides layout-widescreen'>
      
      <article>
        <h1>Let&#39;s Go generic</h1>
        
        
        
          <div class="presenter">
            
  
  <p>
    CodiLime Tech Talk  
  </p>
  

  
  <p>
    March 2022  
  </p>
  

          </div>
        
          <div class="presenter">
            
  
  <p>
    Daniel Furman  
  </p>
  

  
  <p>
    Software Engineer, CodiLime  
  </p>
  

          </div>
        
      </article>
      
  
  
      <article>
      
        <h3>Agenda</h3>
        <ul>
<li>Introduction</li>
<li>Generic programming substitutes (before Go 1.18)</li>
<li>History of Go generics</li>
<li>Dive into Go 1.18 type parameters</li>
<li>Use case: type-safe set implementation</li>
<li>Generics usage recommendations</li>
<li>Future of Go generics</li>
</ul>

      
      <div class="pagenumber">[1]</div>
      </article>
  
  
  
      <article>
      
        <h3>Introduction</h3>
        <ul>
<li>Generic programming enables the representation of functions and data structures in a generic form, with types factored out [30]</li>
<li>Go 1.18 brings generic programming mechanism - type parameters</li>
</ul>

      
      <div class="pagenumber">[2]</div>
      </article>
  
  
  
      <article>
      
        <h3>Generic programming substitutes (before Go 1.18)</h3>
        <p>Go has generic constructs:</p>
<ul>
<li>Types: slice, map, channel</li>
<li>Functions: append(), copy(), delete(), len(), cap(), make(), new(), complex(), real(), imag(), close(), print(), println()</li>
</ul>
<p>One can not define custom generic types/functions</p>

      
      <div class="pagenumber">[3]</div>
      </article>
  
  
  
      <article>
      
        <h3>Generic programming substitutes (before Go 1.18)</h3>
        <p>Approaches we had so far:</p>
<ul>
<li>Manual code duplication</li>
<li>Code duplication via code generation</li>
<li>Operating on empty interfaces (<code>interface{}</code>)</li>
<li>Operating on defined interfaces</li>
<li>Reflections</li>
</ul>
<p>Each approach has its own disadvantages</p>

      
      <div class="pagenumber">[4]</div>
      </article>
  
  
  
      <article>
      
        <h3>Generic programming substitutes - examples</h3>
        <p>Task: implement function returning maximum number in given slice</p>

      
      <div class="pagenumber">[5]</div>
      </article>
  
  
  
      <article>
      
        <h3>Manual code duplication (1/2)</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="13"><b>func MaxInt(s []int) int {</b></span>
<span num="14">    if len(s) == 0 {</span>
<span num="15">        return 0</span>
<span num="16">    }</span>
<span num="17"></span>
<span num="18">    max := s[0]</span>
<span num="19">    for _, v := range s[1:] {</span>
<span num="20">        if v &gt; max {</span>
<span num="21">            max = v</span>
<span num="22">        }</span>
<span num="23">    }</span>
<span num="24">    return max</span>
<span num="25">}</span>
<span num="26"></span>
<span num="27">func ExampleMaxInt() {</span>
<span num="28">    <b>m := MaxInt([]int{4, -8, 15})</b></span>
<span num="29">    fmt.Println(m)                // 15</span>
<span num="30">}</span>
</pre>
</div>

      
      <div class="pagenumber">[6]</div>
      </article>
  
  
  
      <article>
      
        <h3>Manual code duplication (2/2)</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="35"><b>func MaxFloat64(s []float64) float64 {</b></span>
<span num="36">    if len(s) == 0 {</span>
<span num="37">        return 0</span>
<span num="38">    }</span>
<span num="39"></span>
<span num="40">    max := s[0]</span>
<span num="41">    for _, v := range s[1:] {</span>
<span num="42">        if v &gt; max {</span>
<span num="43">            max = v</span>
<span num="44">        }</span>
<span num="45">    }</span>
<span num="46">    return max</span>
<span num="47">}</span>
<span num="48"></span>
<span num="49">func ExampleMaxFloat64() {</span>
<span num="50">    <b>m := MaxFloat64([]float64{4.1, -8.1, 15.1})</b></span>
<span num="51">    fmt.Println(m)                              // 15.1</span>
<span num="52">}</span>
</pre>
</div>

      
      <div class="pagenumber">[7]</div>
      </article>
  
  
  
      <article>
      
        <h3>Manual code duplication</h3>
        <p>Key disadvantages:</p>
<ul>
<li>Lots of manual labour</li>
<li>Code duplication lowers maintainability</li>
</ul>

      
      <div class="pagenumber">[8]</div>
      </article>
  
  
  
      <article>
      
        <h3>Code generation</h3>
        <ul>
<li>We can automate such code duplication via code generation</li>
<li>There are even tools for that, e.g. <a href="https://github.com/cheekybits/genny" target="_blank" rel="noopener">https://github.com/cheekybits/genny</a></li>
</ul>
<p>Key disadvantages:</p>
<ul>
<li>It complicates project build</li>
<li>It increases compilation times</li>
</ul>

      
      <div class="pagenumber">[9]</div>
      </article>
  
  
  
      <article>
      
        <h3>Operating on empty interfaces (1/3)</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="57"><b>func MaxNumber(s []interface{}) (interface{}, error) {</b></span>
<span num="58">    if len(s) == 0 {</span>
<span num="59">        return nil, errors.New(&#34;no values given&#34;)</span>
<span num="60">    }</span>
<span num="61">    // ...</span>
</pre>
</div>

      
      <div class="pagenumber">[10]</div>
      </article>
  
  
  
      <article>
      
        <h3>Operating on empty interfaces (2/3)</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="64">    // ...</span>
<span num="65">    <b>switch first := s[0].(type) {</b></span>
<span num="66">    <b>case int:</b></span>
<span num="67">        max := first</span>
<span num="68">        for _, rawV := range s[1:] {</span>
<span num="69">            <b>v := rawV.(int)</b></span>
<span num="70">            if v &gt; max {</span>
<span num="71">                max = v</span>
<span num="72">            }</span>
<span num="73">        }</span>
<span num="74">        return max, nil</span>
<span num="75">    <b>case float64:</b></span>
<span num="76">        max := first</span>
<span num="77">        for _, rawV := range s[1:] {</span>
<span num="78">            <b>v := rawV.(float64)</b></span>
<span num="79">            if v &gt; max {</span>
<span num="80">                max = v</span>
<span num="81">            }</span>
<span num="82">        }</span>
<span num="83">        return max, nil</span>
<span num="84">    default:</span>
<span num="85">        return nil, fmt.Errorf(&#34;unsupported element type of given slice: %T&#34;, first)</span>
<span num="86">    }</span>
<span num="87">}</span>
</pre>
</div>

      
      <div class="pagenumber">[11]</div>
      </article>
  
  
  
      <article>
      
        <h3>Operating on empty interfaces (3/3)</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="92">func ExampleMaxNumber() {</span>
<span num="93">    <b>m1, err1 := MaxNumber([]interface{}{4, -8, 15})</b></span>
<span num="94">    <b>m2, err2 := MaxNumber([]interface{}{4.1, -8.1, 15.1})</b></span>
<span num="95">    fmt.Println(err1, err2)                               // &lt;nil&gt; &lt;nil&gt;</span>
<span num="96">    fmt.Println(m1, m2)                                   // 15 15.1</span>
<span num="97">}</span>
</pre>
</div>
<p>Key disadvantages:</p>
<ul>
<li>Losing type-safety</li>
<li>Type assertions everywhere</li>
</ul>

      
      <div class="pagenumber">[12]</div>
      </article>
  
  
  
      <article>
      
        <h3>Operating on defined interfaces (1/2)</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="10"><b>func Sort(data sort.Interface) {}</b></span>
<span num="11"></span>
<span num="12"><b>type Interface interface {</b></span>
<span num="13">    // Len is the number of elements in the collection.</span>
<span num="14">    Len() int</span>
<span num="15"></span>
<span num="16">    // Less reports whether the element with index i</span>
<span num="17">    // must sort before the element with index j.</span>
<span num="18">    Less(i, j int) bool</span>
<span num="19"></span>
<span num="20">    // Swap swaps the elements with indexes i and j.</span>
<span num="21">    Swap(i, j int)</span>
<span num="22">}</span>
</pre>
</div>

      
      <div class="pagenumber">[13]</div>
      </article>
  
  
  
      <article>
      
        <h3>Operating on defined interfaces (2/2)</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="27"><b>type IntSlice []int</b></span>
<span num="28"></span>
<span num="29"><b>func (s IntSlice) Len() int {</b></span>
<span num="30">    return len(s)</span>
<span num="31">}</span>
<span num="32"></span>
<span num="33"><b>func (s IntSlice) Less(i, j int) bool {</b></span>
<span num="34">    return s[i] &lt; s[j]</span>
<span num="35">}</span>
<span num="36"></span>
<span num="37"><b>func (s IntSlice) Swap(i, j int) {</b></span>
<span num="38">    s[i], s[j] = s[j], s[i]</span>
<span num="39">}</span>
<span num="40"></span>
<span num="41">func ExampleIntSlice() {</span>
<span num="42">    s := []int{4, -8, 15}</span>
<span num="43">    <b>sort.Sort(IntSlice(s))</b></span>
<span num="44">    fmt.Println(s)         // [-8 4 15]</span>
<span num="45">}</span>
</pre>
</div>
<p>Key disadvantages:</p>
<ul>
<li>Hard to use: requires defining custom types implementing specific methods</li>
</ul>

      
      <div class="pagenumber">[14]</div>
      </article>
  
  
  
      <article>
      
        <h3>Reflections</h3>
        <p>Key disadvantages:</p>
<ul>
<li>low readability</li>
<li>lower performance</li>
</ul>

      
      <div class="pagenumber">[15]</div>
      </article>
  
  
  
      <article>
      
        <h3>History of Go generics</h3>
        <blockquote>
<p>&quot;Generics are convenient, but they come at a cost in complexity in the type system and run-time.
We haven't yet found a design that gives value proportionate to the complexity, although we continue to think about it.&quot; - Go FAQ [1]</p>
</blockquote>

      
      <div class="pagenumber">[16]</div>
      </article>
  
  
  
      <article>
      
        <h3>History of Go generics</h3>
        <ul>
<li>2007-09 - Go language idea</li>
<li>2009-11 - Go became a public open source project</li>
<li>2010-06 - Type functions proposal (#15292)</li>
<li>2011-03 - Generalized types proposal (#15292)</li>
<li>2012-03 - Go 1.0 release</li>
<li>2013-10 - Generalized types proposal II (#15292)</li>
<li>2013-12 - Type parameters proposal (old, #15292)</li>
<li>2016-09 - Compile-time Functions and First Class Types proposal</li>
<li>2018-08 - Go 2 Draft Designs containing generics with contracts</li>
<li>2020-06 - Type parameters draft design</li>
<li>2021-03 - Type parameters proposal (#43651)</li>
<li>2022-03 - Go 1.18 release</li>
</ul>

      
      <div class="pagenumber">[17]</div>
      </article>
  
  
  
      <article>
      
        <h3>Type parameters - Max() example</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="102"><b>func Max[T constraints.Ordered](s []T) T {</b></span>
<span num="103">    if len(s) == 0 {</span>
<span num="104">        return *new(T)</span>
<span num="105">    }</span>
<span num="106"></span>
<span num="107">    max := s[0]</span>
<span num="108">    for _, v := range s[1:] {</span>
<span num="109">        if v &gt; max {</span>
<span num="110">            max = v</span>
<span num="111">        }</span>
<span num="112">    }</span>
<span num="113">    return max</span>
<span num="114">}</span>
<span num="115"></span>
<span num="116">func ExampleMax() {</span>
<span num="117">    <b>m1 := Max[int]([]int{4, -8, 15})</b></span>
<span num="118">    <b>m2 := Max([]float64{4.1, -8.1, 15.1})</b></span>
<span num="119">    fmt.Println(m1, m2)                   // 15 15.1</span>
<span num="120">}</span>
</pre>
</div>

      
      <div class="pagenumber">[18]</div>
      </article>
  
  
  
      <article>
      
        <h3>Type parameters fundamentals</h3>
        <pre><code class="language-go">func Max[T constraints.Ordered](s []T) T {}
m1 := Max[int]([]int{4, -8, 15})
</code></pre>
<p>Type parameters fundamentals [21, 22]:</p>
<ul>
<li>Each type parameter has a type constraint that acts as a kind of meta-type for the type parameter.</li>
<li>Each type constraint specifies the permissible type arguments that calling code can use for the respective type parameter.</li>
<li>At compile time the type parameter stands for a single type – the type provided as a type argument by the calling code.</li>
<li>A type argument is valid if it implements type parameter's constraint.</li>
</ul>

      
      <div class="pagenumber">[19]</div>
      </article>
  
  
  
      <article>
      
        <h3>Type constraints fundamentals (1/2)</h3>
        <ul>
<li>Type constraints are declared as an interface containing methods or union of types</li>
<li>The constraint allows any type satisfying the interface</li>
<li><code>~T</code> means that named types derived from <code>T</code> are accepted</li>
</ul>

  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="7"><b>type StringableFloat interface {</b></span>
<span num="8">    ~float32 | ~float64 // union of types</span>
<span num="9">    String() string</span>
<span num="10">}</span>
<span num="11"></span>
<span num="12">type MyFloat float64 // satisfies StringableFloat type constraints</span>
<span num="13"></span>
<span num="14">func (m MyFloat) String() string {</span>
<span num="15">    return fmt.Sprintf(&#34;%e&#34;, m)</span>
<span num="16">}</span>
</pre>
</div>

      
      <div class="pagenumber">[20]</div>
      </article>
  
  
  
      <article>
      
        <h3>Type constraints fundamentals (2/2)</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="21"><b>func stringifyFloat[T StringableFloat](f T) string {</b></span>
<span num="22">    return f.String()</span>
<span num="23">}</span>
<span num="24"></span>
<span num="25">func ExampleMyFloat() {</span>
<span num="26">    var f MyFloat = 48151623.42</span>
<span num="27">    <b>s := stringifyFloat[MyFloat](f)</b></span>
<span num="28">    fmt.Println(s)                  // 4.815162e&#43;07</span>
<span num="29">}</span>
</pre>
</div>

      
      <div class="pagenumber">[21]</div>
      </article>
  
  
  
      <article>
      
        <h3>Generic type constraints</h3>
        
      
      <div class="pagenumber">[22]</div>
      </article>
  
  
  
      <article>
      
        <h3>Built-in type constraints:</h3>
        <p>Built-in type constraints:</p>
<ul>
<li>any - alias for interface{}</li>
<li>comparable - any type whose values may be used as an operand of the comparison operators == and != (booleans, numbers, strings, pointers, channels, interfaces, arrays of comparable types, structs whose fields are all comparable types)</li>
</ul>
<p>Constraints defined in package constraints:</p>
<ul>
<li>Signed - <code>~int | ~int8 | ~int16 | ~int32 | ~int64</code></li>
<li>Unsigned - <code>~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr</code></li>
<li>Integer - <code>Signed | Unsigned</code></li>
<li>Float - <code>~float32 | ~float64</code></li>
<li>Complex - <code>~complex64 | ~complex128</code></li>
<li>Ordered - <code>Integer | Float | ~string</code> (any type that supports the operators &lt; &lt;= &gt;= &gt;)</li>
</ul>

      
      <div class="pagenumber">[23]</div>
      </article>
  
  
  
      <article>
      
        <h3>Use case: type-safe set implementation</h3>
        <p>Task: implement set data structure</p>

      
      <div class="pagenumber">[24]</div>
      </article>
  
  
  
      <article>
      
        <h3>Use case: type-safe set implementation (1/6)</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="7">// Set implements generic set data structure backed by a hash table.</span>
<span num="8">// It is not thread safe.</span>
<span num="9"><b>type Set[T comparable] struct {</b></span>
<span num="10">    values map[T]struct{}</span>
<span num="11">}</span>
<span num="12"></span>
<span num="13"><b>func NewSet[T comparable](values ...T) *Set[T] {</b></span>
<span num="14">    m := make(map[T]struct{}, len(values))</span>
<span num="15">    for _, v := range values {</span>
<span num="16">        m[v] = struct{}{}</span>
<span num="17">    }</span>
<span num="18">    return &amp;Set[T]{</span>
<span num="19">        values: m,</span>
<span num="20">    }</span>
<span num="21">}</span>
</pre>
</div>

      
      <div class="pagenumber">[25]</div>
      </article>
  
  
  
      <article>
      
        <h3>Use case: type-safe set implementation (2/6)</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="26"><b>func (s *Set[T]) Add(values ...T) {</b></span>
<span num="27">    for _, v := range values {</span>
<span num="28">        s.values[v] = struct{}{}</span>
<span num="29">    }</span>
<span num="30">}</span>
<span num="31"></span>
<span num="32"><b>func (s *Set[T]) Remove(values ...T) {</b></span>
<span num="33">    for _, v := range values {</span>
<span num="34">        delete(s.values, v)</span>
<span num="35">    }</span>
<span num="36">}</span>
<span num="37"></span>
<span num="38"><b>func (s *Set[T]) Contains(values ...T) bool {</b></span>
<span num="39">    for _, v := range values {</span>
<span num="40">        _, ok := s.values[v]</span>
<span num="41">        if !ok {</span>
<span num="42">            return false</span>
<span num="43">        }</span>
<span num="44">    }</span>
<span num="45">    return true</span>
<span num="46">}</span>
</pre>
</div>

      
      <div class="pagenumber">[26]</div>
      </article>
  
  
  
      <article>
      
        <h3>Use case: type-safe set implementation (3/6)</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="51"><b>func (s *Set[T]) Union(other *Set[T]) *Set[T] {</b></span>
<span num="52">    result := NewSet[T](s.Values()...)</span>
<span num="53">    for _, v := range other.Values() {</span>
<span num="54">        if !result.Contains(v) {</span>
<span num="55">            result.Add(v)</span>
<span num="56">        }</span>
<span num="57">    }</span>
<span num="58">    return result</span>
<span num="59">}</span>
<span num="60"></span>
<span num="61"><b>func (s *Set[T]) Intersect(other *Set[T]) *Set[T] {</b></span>
<span num="62">    // pass smaller set first for optimization</span>
<span num="63">    if s.Size() &lt; other.Size() {</span>
<span num="64">        return intersect(s, other)</span>
<span num="65">    }</span>
<span num="66">    return intersect(other, s)</span>
<span num="67">}</span>
</pre>
</div>

      
      <div class="pagenumber">[27]</div>
      </article>
  
  
  
      <article>
      
        <h3>Use case: type-safe set implementation (4/6)</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="72">// intersect returns intersection of given sets. It iterates over smaller set for optimization.</span>
<span num="73"><b>func intersect[T comparable](smaller, bigger *Set[T]) *Set[T] {</b></span>
<span num="74">    result := NewSet[T]()</span>
<span num="75">    for k, _ := range smaller.values {</span>
<span num="76">        if bigger.Contains(k) {</span>
<span num="77">            result.Add(k)</span>
<span num="78">        }</span>
<span num="79">    }</span>
<span num="80">    return result</span>
<span num="81">}</span>
<span num="82"></span>
<span num="83"><b>func (s *Set[T]) Values() []T {</b></span>
<span num="84">    return s.toSlice()</span>
<span num="85">}</span>
</pre>
</div>

      
      <div class="pagenumber">[28]</div>
      </article>
  
  
  
      <article>
      
        <h3>Use case: type-safe set implementation (5/6)</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="90"><b>func (s *Set[T]) Size() int {</b></span>
<span num="91">    return len(s.values)</span>
<span num="92">}</span>
<span num="93"></span>
<span num="94"><b>func (s *Set[T]) Clear() {</b></span>
<span num="95">    s.values = map[T]struct{}{}</span>
<span num="96">}</span>
<span num="97"></span>
<span num="98"><b>func (s *Set[T]) String() string {</b></span>
<span num="99">    return fmt.Sprint(s.toSlice())</span>
<span num="100">}</span>
<span num="101"></span>
<span num="102">func (s *Set[T]) toSlice() []T {</span>
<span num="103">    result := make([]T, 0, len(s.values))</span>
<span num="104">    for k := range s.values {</span>
<span num="105">        result = append(result, k)</span>
<span num="106">    }</span>
<span num="107">    return result</span>
<span num="108">}</span>
</pre>
</div>

      
      <div class="pagenumber">[29]</div>
      </article>
  
  
  
      <article>
      
        <h3>Use case: type-safe set implementation (6/6)</h3>
        
  <div class="code" contenteditable="true" spellcheck="false">
<pre><span num="113">func ExampleSet() {</span>
<span num="114">    <b>s1 := NewSet(4, 4, -8, 15)</b></span>
<span num="115">    <b>s2 := NewSet(&#34;foo&#34;, &#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;)</b></span>
<span num="116">    fmt.Println(s1.Size(), s2.Size())        // 3, 3</span>
<span num="117"></span>
<span num="118">    s1.Add(-16)</span>
<span num="119">    s2.Add(&#34;hoge&#34;)</span>
<span num="120">    fmt.Println(s1.Size(), s2.Size())                  // 4, 4</span>
<span num="121">    fmt.Println(s1.Contains(-16), s2.Contains(&#34;hoge&#34;)) // true, true</span>
<span num="122"></span>
<span num="123">    s1.Remove(15)</span>
<span num="124">    s2.Remove(&#34;baz&#34;)</span>
<span num="125">    fmt.Println(s1.Size(), s2.Size()) // 3, 3</span>
<span num="126"></span>
<span num="127">    fmt.Println(len(s1.Values()), len(s2.Values())) // 3, 3</span>
<span num="128"></span>
<span num="129">    <b>s3 := NewSet(&#34;hoge&#34;, &#34;dragon&#34;, &#34;fly&#34;)</b></span>
<span num="130">    fmt.Println(s2.Union(s3).Size())      // 5</span>
<span num="131">    fmt.Println(s2.Intersect(s3))         // [hoge]</span>
<span num="132"></span>
<span num="133">    s1.Clear()</span>
<span num="134">    s2.Clear()</span>
<span num="135">    fmt.Println(s1.Size(), s2.Size()) // 0, 0</span>
<span num="136">}</span>
</pre>
</div>

      
      <div class="pagenumber">[30]</div>
      </article>
  
  
  
      <article>
      
        <h3>Generics usage recommendations</h3>
        <p>Use cases for generics [30]:</p>
<ul>
<li>functions calculating max/min/average/mode/standard deviation of elements in a slice or maps</li>
<li>transformation functions for slices or maps</li>
<li>generic data structures, e.g. set, multimap, concurrent hash map, graph, tree, linked list with appropriate generic methods</li>
<li>functions operating on channels, e.g. combine two channels into single channel</li>
<li>functions operating on functions, e.g. call given functions in parallel and return a slice of results</li>
</ul>

      
      <div class="pagenumber">[31]</div>
      </article>
  
  
  
      <article>
      
        <h3>When not to use generics</h3>
        
      
      <div class="pagenumber">[32]</div>
      </article>
  
  
  
      <article>
      
        <h3>Future of Go generics</h3>
        <ul>
<li>Growing number of libraries using generics:
<ul>
<li><a href="https://github.com/mikhailswift/go-collections" target="_blank" rel="noopener">github.com/mikhailswift/go-collections</a></li>
<li><a href="https://github.com/johnmurray/typed" target="_blank" rel="noopener">github.com/johnmurray/typed</a></li>
</ul>
</li>
<li>Go 1.19 (~08.2022): stdlib packages to use generics:
<ul>
<li><a href="https://github.com/golang/exp/tree/master/constraints" target="_blank" rel="noopener">github.com/golang/exp/constraints</a></li>
<li><a href="https://github.com/golang/exp/tree/master/maps" target="_blank" rel="noopener">github.com/golang/exp/maps</a></li>
<li><a href="https://github.com/golang/exp/tree/master/slices" target="_blank" rel="noopener">github.com/golang/exp/slices</a></li>
</ul>
</li>
</ul>

      
      <div class="pagenumber">[33]</div>
      </article>
  
  
  
      <article>
      
        <h3>Summary</h3>
        <ul>
<li>Arguably the biggest shortcoming of Go is going to be resolved soon</li>
<li>Type parameters is powerful feature, but can (and will) be overused</li>
<li>There was never better time to give Go a go</li>
</ul>

      
      <div class="pagenumber">[34]</div>
      </article>
  
  
  
      <article>
      
        <h3>References (1/4)</h3>
        <p class="link"><a href="https://github.com/golang/proposal/blob/master/design/15292-generics.md" target="_blank">[1] Proposal: Go should have generics (2011-01)</a></p><p class="link"><a href="https://github.com/golang/proposal/blob/master/design/15292/2010-06-type-functions.md" target="_blank">[2] Type Functions Proposal (2010-06)</a></p><p class="link"><a href="https://github.com/golang/proposal/blob/master/design/15292/2011-03-gen.md" target="_blank">[3] Proposal: Generalized Types (2011-03)</a></p><p class="link"><a href="https://github.com/golang/proposal/blob/master/design/15292/2013-10-gen.md" target="_blank">[4] Proposal: Generalized Types II (2013-10)</a></p><p class="link"><a href="https://github.com/golang/proposal/blob/master/design/15292/2013-12-type-params.md" target="_blank">[5] Proposal: Type Parameters (2013-12)</a></p><p class="link"><a href="https://github.com/golang/proposal/blob/master/design/15292/2016-09-compile-time-functions.md" target="_blank">[6] Proposal: Compile-time Functions and First Class Types (2016-09)</a></p><p class="link"><a href="https://github.com/golang/proposal/blob/master/design/go2draft-generics-overview.md" target="_blank">[7] Generics — Problem Overview (2018-08)</a></p><p class="link"><a href="https://github.com/golang/proposal/blob/master/design/go2draft-contracts.md" target="_blank">[8] Draft Design: Contracts 2018-08</a></p><p class="link"><a href="https://github.com/golang/proposal/blob/master/design/43651-type-parameters.md" target="_blank">[9] Proposal: Type Parameters (2021-03)</a></p><p class="link"><a href="https://github.com/golang/proposal/blob/master/design/44253-generic-array-sizes.md" target="_blank">[10] Proposal: Generic parameterization of array sizes (2021-03)</a></p>
      
      <div class="pagenumber">[35]</div>
      </article>
  
  
  
      <article>
      
        <h3>References (2/4)</h3>
        <p class="link"><a href="https://github.com/golang/proposal/blob/master/design/47781-parameterized-go-ast.md" target="_blank">[11] Proposal: Additions to go/ast and go/token to support parameterized functions and types (2021-08)</a></p><p class="link"><a href="https://github.com/golang/proposal/blob/master/design/47916-parameterized-go-types.md" target="_blank">[12] Proposal: Additions to go/types to support type parameters (2021-08)</a></p><p class="link"><a href="https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/preview" target="_blank">[13] Summary of Go Generics Discussions</a></p><p class="link"><a href="https://github.com/golang/go/issues/43651" target="_blank">[14] spec: add generic programming using type parameters #43651 (Jan 12, 2021)</a></p><p class="link"><a href="https://github.com/golang/go/issues/45346" target="_blank">[15] spec: generics: use type sets to remove type keyword in constraints #45346 (Apr 2021)</a></p>
      
      <div class="pagenumber">[36]</div>
      </article>
  
  
  
      <article>
      
        <h3>References (3/4)</h3>
        <p class="link"><a href="https://go.dev/doc/faq#generics" target="_blank">[20] Go FAQ: Why does Go not have generic types?</a></p><p class="link"><a href="https://go.dev/doc/tutorial/generics" target="_blank">[21] Tutorial: Getting started with generics</a></p><p class="link"><a href="https://github.com/golang/go/wiki/Go2GenericsFeedback" target="_blank">[22] Go 2 Generics Feedback</a></p><p class="link"><a href="https://github.com/golang/go/wiki/Go2" target="_blank">[23] Go2 status</a></p><p class="link"><a href="https://tip.golang.org/doc/go1.18" target="_blank">[24] Go 1.18 Release Notes</a></p><p class="link"><a href="https://github.com/golang/go/discussions/48287" target="_blank">[25] how to update APIs for generics #48287</a></p><p class="link"><a href="https://groups.google.com/g/golang-dev/c/iuB22_G9Kbo/m/7B1jd1I3BQAJ" target="_blank">[26] Expectations for generics in Go 1.18</a></p>
      
      <div class="pagenumber">[37]</div>
      </article>
  
  
  
      <article>
      
        <h3>References (4/4)</h3>
        <p class="link"><a href="https://www.youtube.com/watch?v=WzgLqE-3IhY" target="_blank">[30] GopherCon 2019: Ian Lance Taylor -Generics in Go</a></p><p class="link"><a href="https://www.youtube.com/watch?v=TborQFPY2IM" target="_blank">[31] GopherCon 2020: Robert Griesemer - Typing Generic Go</a></p><p class="link"><a href="https://www.youtube.com/watch?v=Pa_e9EeCdy8" target="_blank">[32] GopherCon 2021: Robert Griesemer &amp; Ian Lance Taylor - Generics!</a></p><p class="link"><a href="https://www.youtube.com/watch?v=uh5pXt6d1nE&amp;" target="_blank">[33] Golang Poland #4 - Bill Kennedy - Generics Draft Proposal Review</a></p><p class="link"><a href="https://www.youtube.com/watch?v=nr8EpUO9jhw" target="_blank">[34] Go Day 2021 on Google Open Source Live | Using Generics in Go</a></p><p class="link"><a href="https://github.com/ardanlabs/gotraining/tree/master/topics/go/generics" target="_blank">[35] github.com/ardanlabs/gotraining - generics</a></p>
      
      <div class="pagenumber">[38]</div>
      </article>
  
  

      <article>
        <h3>Thank you</h1>
        
          <div class="presenter">
            
  
  <p>
    CodiLime Tech Talk  
  </p>
  

  
  <p>
    March 2022  
  </p>
  
<p class="link"><a href="#ZgotmplZ" target="_blank">Tags: Go, generics, types, interface, parametric polymorphism</a></p>
          </div>
        
          <div class="presenter">
            
  
  <p>
    Daniel Furman  
  </p>
  

  
  <p>
    Software Engineer, CodiLime  
  </p>
  
<p class="link"><a href="mailto:daniel.furman@codilime.com" target="_blank">daniel.furman@codilime.com</a></p><p class="link"><a href="#ZgotmplZ" target="_blank">gophers.slack.com: @danielfurman</a></p><p class="link"><a href="#ZgotmplZ" target="_blank">Github: @danielfurman</a></p><p class="link"><a href="#ZgotmplZ" target="_blank">Twitter: @danielfurman88</a></p><p class="link"><a href="#ZgotmplZ" target="_blank">LinkedIn: @danielfurman8</a></p>
          </div>
        
      </article>

  </body>
  
</html>
